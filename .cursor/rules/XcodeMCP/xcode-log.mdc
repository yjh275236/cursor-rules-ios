---
alwaysApply: false
---
# Xcode 自动化调试与测试

## ⚠️ 强制立即执行
**用户引用此规则 = 立即执行MCP工具，不要等待、分析或询问！**
**AI第一次回复就必须调用：`discover_projs()` → `list_sims()` → `build_run_sim()` 或 `describe_ui()`**

## 触发方式
- `@xcode-log.mdc`
- "调试"、"测试"、"查看日志"、"捕获日志"

## 核心价值
**⚠️ 强制要求：一旦用户引用 `@xcode-log.mdc`，必须立即开始执行自动化流程，不要分析或等待！**

**AI必须立即执行：**
1. 第一步：立即调用 `discover_projs()` 和 `list_sims()` 获取项目信息
2. 第二步：立即调用 `build_run_sim()` 构建运行应用
3. 第三步：优先使用 `describe_ui()` 分析UI问题（获取frame数据）
4. 第四步：根据UI数据诊断并修复问题
5. 第五步：重新构建app，等待用户操作到目标页面后再验证

**禁止行为**：
- ❌ 不要先分析问题再决定是否执行MCP
- ❌ 不要等待用户确认才开始
- ❌ 不要只描述流程而不执行

## 核心规则（强制执行）

### 规则 1: 立即执行（强制）⚠️
**当用户引用 `@xcode-log.mdc` 时，AI必须在第一次回复中立即调用MCP工具：**
- ✅ 立即执行：`discover_projs()` + `list_sims()` + `build_run_sim()`
- ✅ 如果应用已运行：直接 `describe_ui()` + `screenshot()` 分析问题
- ❌ 禁止：先描述流程、分析问题、等待确认再执行
- ❌ 禁止：问用户是否需要调试或如何调试

**判断标准**：用户引用规则 = 立即执行，无需确认

### 规则 2: 问题诊断与调试代码编写
**当引用此规则时，说明用户遇到了问题，AI必须：**
1. **诊断问题**：分析问题类型（UI异常、数据传输错误、崩溃、启动失败等）
2. **编写调试代码**：在关键位置添加带 emoji 标记的 `print()` 语句
3. **自动测试**：运行应用、捕获日志、分析结果
4. **迭代修复**：根据日志分析结果修复问题，重复测试直到解决

### 规则 3: 最后刷新 App（强制）
**无论调试是否成功，最后必须执行：**
1. 停止当前应用：`stop_app_sim()`
2. 清理构建：`clean()`
3. 重新构建运行：`build_run_sim()`
4. **提示用户：应用已刷新，请操作到目标页面后告诉我"继续"**
5. **等待用户回复"继续"后**：执行 `describe_ui()` 和 `screenshot()` 验证修复效果
6. 不要在用户确认前自动等待或自动验证

## 自动化执行流程

### 完整自动化调试流程
```javascript
// === 第一步：自动检测项目环境 ===
1. discover_projs({ workspaceRoot: "/Users/yjh/Desktop/Design patterns" })
   → 获取: projectPath/workspacePath, scheme

2. list_sims()
   → 获取: 运行中的模拟器 UUID（优先使用 Booted 状态）

// === 第二步：问题诊断（根据用户描述或实际情况） ===
3. 分析问题类型：
   - UI 问题：describe_ui() 检查当前 UI 状态
   - 启动问题：检查应用是否运行
   - 数据传输问题：检查相关代码和日志
   - 崩溃问题：检查崩溃日志

// === 第三步：编写调试代码 ===
4. 在关键位置添加调试 print() 语句：
   - 问题相关的函数入口
   - 关键数据变化点
   - 异常处理位置
   
   使用 emoji 标记：
   ✅ 成功执行
   ❌ 错误
   ⚠️ 警告
   🔍 调试信息
   📡 网络请求
   💾 数据存储
   🎨 UI 渲染

// === 第四步：自动化测试 ===
5. build_run_sim({
     projectPath/workspacePath: "...",
     scheme: "...",
     simulatorName/UUID: "..."
   })

6. sleep(3-5) // 等待应用启动

7. launch_app_logs_sim({
     simulatorUuid: "...",
     bundleId: "com.daiwo.zydd"
   })
   → 返回 sessionId

8. sleep(3-5) // 等待日志产生

9. stop_device_log_cap({ logSessionId: "..." })
   → 获取日志内容

10. describe_ui({ simulatorUuid: "..." })
    → 检查 UI 状态

// === 第五步：分析结果并修复 ===
11. 分析日志，定位问题
12. 修复代码
13. 如果问题未解决，回到步骤 4，继续迭代

// === 第六步：最后刷新 App（强制执行） ===
14. stop_app_sim({
      simulatorUuid: "...",
      bundleId: "com.daiwo.zydd"
    })

15. clean({
      projectPath/workspacePath: "...",
      scheme: "...",
      platform: "iOS Simulator"
    })

16. build_run_sim({
      projectPath/workspacePath: "...",
      scheme: "...",
      simulatorName/UUID: "..."
    })

17. **提示用户：应用已刷新，请操作到目标页面后告诉我"继续"**

18. **等待用户回复"继续"**

19. describe_ui({ simulatorUuid: "..." })
    → 验证最终状态

20. screenshot({ simulatorUuid: "..." })
    → 截图供用户检查

21. 分析验证结果，确认问题已解决
```

## 调试代码编写规范

### Emoji 标记标准
```swift
// ✅ 成功执行
print("✅ AppDelegate: didFinishLaunching called")
print("✅ ViewController: viewDidLoad called")
print("✅ Data: Successfully loaded \(count) items")

// ❌ 错误
print("❌ Error: Failed to load data - \(error.localizedDescription)")
print("❌ Network: Request failed with status \(statusCode)")

// ⚠️ 警告
print("⚠️ Warning: Data is nil, using default value")
print("⚠️ UI: Frame is zero, view may not be laid out")

// 🔍 调试信息
print("🔍 Debug: Current count = \(count)")
print("🔍 Debug: Entering function processData()")

// 📡 网络请求
print("📡 Network: Starting request to \(url)")
print("📡 Network: Response received: \(response)")

// 💾 数据存储
print("💾 Data: Saving to UserDefaults")
print("💾 Data: Loading from cache")

// 🎨 UI 渲染
print("🎨 UI: View frame set to \(frame)")
print("🎨 UI: Updating \(subviewCount) subviews")
```

### 关键位置添加调试代码

#### UI 问题调试
```swift
// ViewController.swift
override func viewDidLoad() {
    super.viewDidLoad()
    print("✅ ViewController: viewDidLoad called")
    print("🎨 UI: View frame: \(view.frame)")
    // ... 其他代码 ...
}

override func viewWillAppear(_ animated: Bool) {
    super.viewWillAppear(animated)
    print("✅ ViewController: viewWillAppear called")
    // ... 其他代码 ...
}

override func viewDidLayoutSubviews() {
    super.viewDidLayoutSubviews()
    print("🎨 UI: viewDidLayoutSubviews called, frame: \(view.frame)")
}
```

#### 数据传输问题调试
```swift
// 数据加载
func loadData() {
    print("🔍 Debug: Starting loadData()")
    print("📡 Network: Requesting data from \(urlString)")
    
    // ... 网络请求 ...
    
    completionHandler { result in
        switch result {
        case .success(let data):
            print("✅ Data: Successfully loaded \(data.count) items")
            print("💾 Data: First item: \(data.first?.description ?? "nil")")
        case .failure(let error):
            print("❌ Error: Failed to load data - \(error.localizedDescription)")
        }
    }
}

// 数据处理
func processData(_ data: [Item]) {
    print("🔍 Debug: Processing \(data.count) items")
    for (index, item) in data.enumerated() {
        print("🔍 Debug: Item \(index): \(item.description)")
    }
}
```

#### 启动问题调试
```swift
// AppDelegate.swift
func application(_ application: UIApplication, 
                didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
    print("✅ AppDelegate: didFinishLaunchingWithOptions called")
    
    // ... 窗口创建代码 ...
    
    if window != nil {
        print("✅ AppDelegate: Window created successfully")
        print("🎨 UI: Window frame: \(window!.frame)")
    } else {
        print("❌ Error: Failed to create window")
    }
    
    return true
}

// SceneDelegate.swift（如果使用 Scene）
func scene(_ scene: UIScene, willConnectTo session: UISceneSession, 
           options connectionOptions: UIScene.ConnectionOptions) {
    print("✅ SceneDelegate: willConnectTo called")
    
    guard let windowScene = (scene as? UIWindowScene) else {
        print("❌ Error: Failed to cast scene to UIWindowScene")
        return
    }
    
    print("✅ SceneDelegate: Window scene created")
}
```

## 问题诊断指南

### UI 问题诊断（首选方法）⭐
```
问题现象：布局异常、间距错误、元素重叠、大小不对

诊断流程（优先使用 describe_ui）：
1. build_run_sim() → 构建运行应用
2. **提示用户操作到问题页面，回复"继续"**
3. describe_ui() → 获取完整UI层次和frame数据
4. **分析frame数据**：
   - 检查元素的 x, y, width, height
   - 计算实际间距：下一个元素.y - (当前元素.y + 当前元素.height)
   - 对比设计值，定位问题元素
5. **根据frame数据直接修复约束**，无需添加调试print
6. 重新构建 → 等待用户操作 → 验证修复

优势：
✅ 直接获取准确的像素数据，无需猜测
✅ 不需要添加临时调试代码
✅ 快速定位布局异常的根本原因

仅在以下情况使用调试print：
- 动态数据问题（数据未显示、数据错误）
- 崩溃问题
- 生命周期问题

示例（弹窗间距问题）：
describe_ui() 返回：
  - titleLabel: {y: 140.5, height: 140.5} ❌ 异常！正常应该~20px
  - descriptionLabel: {y: 296, height: 33.5}
  - 实际间距：296 - (140.5 + 140.5) = 15px ✅
  
分析：标题高度被异常拉伸到140.5px（正常20px）
修复：添加 contentHuggingPriority 防止拉伸
验证：重新构建后 titleLabel.height = 21.5px ✅
```

### 数据传输问题诊断
```
问题现象：数据不显示、数据错误、网络请求失败

诊断流程：
1. 添加调试代码：
   - 网络请求开始/结束
   - 数据解析成功/失败
   - 数据更新到 UI
2. 捕获日志，检查数据流转：
   - 请求是否发送
   - 响应是否接收
   - 数据是否正确解析
   - UI 是否正确更新
3. 根据日志定位问题
```

### 启动问题诊断
```
问题现象：应用无法启动、崩溃、启动后立即退出

诊断流程：
1. build_run_sim() 启动应用
2. 立即 capture logs
3. 检查关键日志：
   - AppDelegate: didFinishLaunching
   - SceneDelegate: willConnectTo
   - ViewController: viewDidLoad
4. 如果缺少某个日志，说明该步骤未执行
5. 检查崩溃信息
```

### 崩溃问题诊断
```
问题现象：应用崩溃

诊断流程：
1. build_run_sim() 启动应用
2. launch_app_logs_sim() 捕获日志
3. 查找崩溃堆栈信息
4. 定位崩溃位置和原因
5. 修复代码并重新测试
```

## 日志分析要点

### 关键日志检查清单
```
启动流程：
- [ ] ✅ AppDelegate: didFinishLaunching
- [ ] ✅ SceneDelegate: willConnectTo（如果使用 Scene）
- [ ] ✅ ViewController: viewDidLoad
- [ ] ✅ ViewController: viewWillAppear

数据流程：
- [ ] 📡 Network: Request started
- [ ] 📡 Network: Response received
- [ ] ✅ Data: Successfully loaded
- [ ] 🎨 UI: Updating UI with data

UI 流程：
- [ ] 🎨 UI: View frame set
- [ ] 🎨 UI: viewDidLayoutSubviews called
- [ ] ✅ ViewController: 生命周期方法执行

错误检查：
- [ ] ❌ Error: 任何错误信息
- [ ] ⚠️ Warning: 任何警告信息
```

## 调试代码清理（完成后）

### 清理原则
**调试完成后，必须删除所有临时调试代码：**

1. **删除调试 print()**
   - 删除所有带 emoji 标记的 print 语句
   - 保留必要的错误处理 print

2. **验证清理**
   ```bash
   grep -r "print(" --include="*.swift" | grep "✅\|❌\|⚠️\|🔍\|📡\|💾\|🎨\|Debug"
   ```

3. **清理清单**
   - [ ] AppDelegate/SceneDelegate 中无调试 print
   - [ ] ViewController 生命周期方法中无调试 print
   - [ ] 数据加载方法中无调试 print
   - [ ] 仅保留必要的错误处理输出

## 项目配置
- Bundle ID: `com.daiwo.zydd`（或当前项目）
- 默认模拟器: `iPhone SE (3rd generation)`
- 项目路径: `/Users/yjh/Desktop/Design patterns`

## 注意事项
- ⚠️ **立即执行**：看到 `@xcode-log.mdc` 后，第一次回复就必须调用MCP工具，不要等第二次
- **强制执行**：引用此规则时，必须完成整个自动化流程，不得中途停止
- **最后刷新**：无论调试结果如何，最后必须重新构建运行 app
- **UI问题优先用describe_ui**：直接分析frame数据，不要猜测或添加调试代码
- **等待用户操作**：重启后不要自动sleep等待，而是提示用户操作到目标页面
- **迭代调试**：如果问题未解决，继续重复调试流程直到解决

## 快速启动检查清单
**用户引用 @xcode-log.mdc 时，AI第一次回复必须：**
- [ ] 立即调用 `discover_projs()` 和 `list_sims()`
- [ ] 立即调用 `build_run_sim()` 或 `describe_ui()`（如果已运行）
- [ ] 不要问用户"是否需要调试"或"如何调试"
- [ ] 不要只描述流程而不执行
