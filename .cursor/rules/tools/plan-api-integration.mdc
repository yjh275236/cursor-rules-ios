---
alwaysApply: false
---
# 接口对接规范

## 目标

规范 UI 页面完成后对接真实接口的流程，确保代码质量、状态处理完整性和数据一致性。

**适用场景**：UI 页面设计完成后，需要对接后端接口时使用。

---

## 1. 接口对接前检查清单 ⭐

### 必须执行的检查

在开始对接接口前，必须完成以下检查：

- [ ] **确认接口信息**
  - [ ] 接口路径、HTTP 方法（GET/POST/PUT/DELETE）
  - [ ] 请求参数（Query、Body、Header）
  - [ ] 响应数据结构（字段名、类型、嵌套结构）
  - [ ] 是否需要认证（token、特殊 header）

- [ ] **检查项目架构**
  - [ ] 搜索项目中的网络请求基类（如 `BaseRequest`、`SSBaseRequest` 等）
  - [ ] 确认网络请求的封装方式和调用规范
  - [ ] 检查是否有统一的错误处理机制
  - [ ] 确认 Model 的命名规范和存放位置

- [ ] **检查现有代码**
  - [ ] 确认当前页面使用的模拟数据结构
  - [ ] 确认 UI 绑定的数据字段
  - [ ] 确认需要处理的状态（loading、error、empty、success）

**执行时机**：UI 页面完成后，准备对接接口前

---

## 2. 使用 Newman 测试接口 ⭐

### 2.1 为什么先测试接口

在创建 Model 和对接接口前，**强烈建议**先使用 Newman 测试接口，了解：
- 实际接口返回的数据格式和结构
- 字段的真实类型和可选性
- 嵌套结构的实际层级
- 错误响应的格式
- 空数据的处理方式

这样可以避免根据接口文档创建 Model 后，发现实际数据格式不一致的问题。

### 2.2 创建 Postman Collection

- [ ] **创建 Collection 文件**
  - 创建 `[接口名]-collection.json` 文件
  - 配置接口路径、方法、请求参数
  - 配置环境变量（baseUrl、认证信息等）

- [ ] **创建 Environment 文件**
  - 创建 `[接口名]-environment.json` 文件
  - 配置服务器地址、测试账号等
  - 按照 Postman Collection 标准格式创建（包含 baseUrl、认证信息等变量）

### 2.3 运行 Newman 测试

- [ ] **运行测试命令**
  ```bash
  # 方法一：临时禁用代理运行（推荐）
  unset https_proxy http_proxy HTTP_PROXY HTTPS_PROXY && newman run [collection].json -e [environment].json --insecure
  
  # 方法二：使用环境变量
  env https_proxy= http_proxy= HTTP_PROXY= HTTPS_PROXY= newman run [collection].json -e [environment].json --insecure
  ```

- [ ] **分析响应数据**
  - 查看成功响应的完整 JSON 结构
  - 确认字段名、类型、嵌套关系
  - 确认哪些字段是必填的，哪些是可选的
  - 查看错误响应的格式
  - 测试空数据场景

- [ ] **记录关键信息**
  - 记录实际返回的字段名（可能与文档不一致）
  - 记录字段的实际类型（如数字可能是 String）
  - 记录嵌套结构的实际层级
  - 记录错误码和错误信息格式

### 2.4 基于实际数据创建 Model

- [ ] **根据实际响应创建 Model**
  - 使用 Newman 测试得到的实际响应数据
  - 确保字段名与实际返回一致
  - 根据实际数据类型定义 Model 字段类型
  - 根据实际返回情况确定可选性

**执行时机**：在"接口对接前检查清单"完成后，创建 Model 之前

**参考文档**：如果项目中有 Newman 使用文档，可参考其使用说明。Newman 是 Postman 的命令行工具，用于运行 Postman Collection。

---

## 3. Model 创建规范 ⭐

### 3.1 Model 结构规范

**必须遵循**：

- [ ] **实现 Codable 协议**
  ```swift
  struct UserModel: Codable {
      let id: Int
      let name: String
      let account: String
  }
  ```

- [ ] **字段命名规范**
  - 使用 `camelCase` 命名（符合 Swift 规范）
  - 字段名与接口文档保持一致
  - 如果接口使用 `snake_case`，使用 `CodingKeys` 映射

- [ ] **可选字段处理**
  - 接口可能不返回的字段使用 `Optional`（`?`）
  - 接口一定返回但可能为 `null` 的字段使用 `Optional`
  - 接口一定返回且不为空的字段使用非可选类型

- [ ] **嵌套结构处理**
  - 嵌套对象创建独立的 Model
  - 数组类型使用 `[ItemModel]`
  - 复杂嵌套结构正确映射

### 3.2 CodingKeys 使用规范

当接口字段名与 Swift 命名规范不一致时，使用 `CodingKeys`：

```swift
struct UserModel: Codable {
    let firstName: String
    let lastName: String
    let accountType: Int
    
    enum CodingKeys: String, CodingKey {
        case firstName = "first_name"
        case lastName = "last_name"
        case accountType = "account_type"
    }
}
```

### 3.3 Model 命名规范

- **推荐**：`[功能]Model`（如 `UserModel`、`BankModel`）
- **或**：直接使用功能名（如 `User`、`Bank`）
- **禁止**：使用 `[功能]Data`、`[功能]Info` 等不规范命名

### 3.4 Model 存放位置

- 按功能模块组织，放在对应的 Model 目录
- 或统一放在 `Models/` 目录下
- 遵循项目的目录结构规范

---

## 4. 网络请求规范 ⭐

### 4.1 使用项目统一的网络请求封装

**必须执行**：

- [ ] **搜索现有网络请求基类**
  - 搜索 `BaseRequest`、`SSBaseRequest`、`NetworkManager` 等
  - 查看现有接口请求的实现方式
  - 复用项目的网络请求封装，不得自行实现

- [ ] **遵循项目请求规范**
  - 使用项目定义的请求基类
  - 遵循项目的请求方法命名规范
  - 使用项目统一的错误处理机制

### 4.2 请求参数构建

- [ ] **Query 参数**
  - 使用字典或结构体构建
  - 可选参数正确处理（nil 值不传递）

- [ ] **Body 参数**
  - POST/PUT 请求使用 JSON 格式
  - 参数类型与接口文档一致
  - 嵌套参数正确构建

- [ ] **Header 参数**
  - 认证 token 使用项目统一方式添加
  - Content-Type 等标准 header 由封装层处理

### 4.3 错误处理规范

- [ ] **统一错误处理**
  - 使用项目统一的错误处理机制
  - 错误信息正确展示给用户
  - 网络错误、业务错误区分处理

---

## 5. UI 状态处理规范 ⭐

### 5.1 必须处理的四种状态

对接接口时，**必须**处理以下四种状态：

#### 5.1.1 Loading 状态（请求中）

- [ ] 显示加载指示器（如 `UIActivityIndicatorView`）
- [ ] 禁用用户交互（防止重复请求）
- [ ] 显示加载提示（可选）

```swift
// 示例：显示加载状态
func showLoading() {
    activityIndicator.startAnimating()
    view.isUserInteractionEnabled = false
}
```

#### 5.1.2 Success 状态（数据展示）

- [ ] 隐藏加载指示器
- [ ] 恢复用户交互
- [ ] 更新 UI 数据绑定
- [ ] 处理空数据情况（见 Empty 状态）

```swift
// 示例：处理成功响应
func handleSuccess(data: UserModel) {
    activityIndicator.stopAnimating()
    view.isUserInteractionEnabled = true
    updateUI(with: data)
}
```

#### 5.1.3 Error 状态（错误提示）

- [ ] 隐藏加载指示器
- [ ] 恢复用户交互
- [ ] 显示错误提示（Toast、Alert 等）
- [ ] 错误信息友好展示（不要直接显示技术错误）

```swift
// 示例：处理错误
func handleError(_ error: Error) {
    activityIndicator.stopAnimating()
    view.isUserInteractionEnabled = true
    showErrorAlert(message: error.localizedDescription)
}
```

#### 5.1.4 Empty 状态（空数据）

- [ ] 数据为空时显示空状态 UI
- [ ] 提供刷新或重新加载的入口
- [ ] 空状态提示信息友好

```swift
// 示例：处理空数据
func handleEmpty() {
    showEmptyStateView(message: "暂无数据")
}
```

### 5.2 状态切换时机

- **请求开始**：切换到 Loading 状态
- **请求成功**：切换到 Success 状态（或 Empty 状态）
- **请求失败**：切换到 Error 状态
- **状态切换必须在主线程**：使用 `DispatchQueue.main.async`

---

## 6. 数据替换规范 ⭐

### 6.1 替换模拟数据

从模拟数据切换到真实接口时，**必须删除**：

- [ ] **所有模拟数据定义**
  - 删除模拟数组（如 `let mockData = [...]`）
  - 删除模拟字典（如 `let mockDict = [...]`）
  - 删除硬编码的测试数据

- [ ] **Mock 函数和方法**
  - 删除 `loadMockData()` 等模拟方法
  - 删除 `generateFakeData()` 等假数据生成函数
  - 删除所有模拟数据相关的辅助函数

- [ ] **临时的模拟 Model**
  - 如果创建了临时的模拟 Model，删除它们
  - 确保使用真实的 Model（实现 Codable）

- [ ] **测试用的假数据填充代码**
  - 删除用于填充假数据的代码
  - 删除测试用的数据初始化代码

- [ ] **遗留的模拟数据注释代码**
  - 删除注释掉的模拟数据代码
  - 清理不再使用的模拟数据相关注释

### 6.2 更新数据绑定逻辑

- [ ] **更新数据源**
  - 将模拟数据源替换为网络请求返回的数据
  - 确保数据绑定逻辑正确

- [ ] **更新 UI 更新方法**
  - 确保 UI 更新方法使用真实数据
  - 处理数据可能为空的情况

### 6.3 清理步骤

1. 识别所有模拟数据相关代码
2. 确认要删除的代码范围
3. 执行删除操作
4. 验证删除后代码的完整性
5. 确保功能正常（使用真实接口测试）

---

## 7. 接口对接后验证清单 ⭐

### 7.1 功能验证

- [ ] **数据正确展示**
  - 接口返回的数据正确显示在 UI 上
  - 字段映射正确（字段名、类型）
  - 嵌套数据正确解析和展示

- [ ] **状态处理验证**
  - Loading 状态正确显示和隐藏
  - Success 状态数据正确展示
  - Error 状态错误信息正确提示
  - Empty 状态空数据正确展示

### 7.2 场景测试

- [ ] **正常场景**
  - 接口返回正常数据，UI 正确展示

- [ ] **错误场景**
  - 网络错误（无网络、超时等）
  - 业务错误（接口返回错误码）
  - 服务器错误（500 等）

- [ ] **空数据场景**
  - 接口返回空数组
  - 接口返回 null 数据
  - 接口返回空对象

- [ ] **边界场景**
  - 数据量很大时的性能
  - 特殊字符、特殊格式的数据
  - 极值数据（最大、最小）

### 7.3 代码质量验证

- [ ] **代码清理验证**
  - 确认所有模拟数据已删除
  - 确认所有 Mock 函数已删除
  - 确认代码中没有遗留的测试代码

- [ ] **架构规范验证**
  - 确认使用了项目统一的网络请求封装
  - 确认 Model 符合项目规范
  - 确认错误处理符合项目规范

---

## 8. 与现有规则的配合

### 8.1 与 Plan 文档同步规则配合

- **接口对接完成后**：检查是否需要更新 plan 文档
  - 如果接口信息在 plan 文档中，更新接口说明
  - 如果功能需求有变化，更新功能需求部分

### 8.2 与代码清理规则配合

- **数据替换**：遵循 `03-project-plan-sync.mdc` 中的"代码清理规则"
- **UI 修改**：如果接口对接导致 UI 调整，删除废弃的 UI 代码

### 8.3 与架构检查规则配合

- **网络请求**：遵循 `03-project-plan-sync.mdc` 中的"架构检查规则"
- **复用组件**：必须复用项目现有的网络请求封装和工具类

---

## 执行时机总结

| 时机 | 必须执行的操作 |
|---|---|
| UI 页面完成后 | 执行"接口对接前检查清单" |
| 检查清单完成后 | 使用 Newman 测试接口，了解实际数据格式 |
| 创建 Model 时 | 基于 Newman 测试结果，遵循"Model 创建规范" |
| 创建网络请求时 | 遵循"网络请求规范"，复用项目封装 |
| 实现数据绑定前 | 确保处理"UI 状态处理规范"的四种状态 |
| 替换模拟数据时 | 执行"数据替换规范"，删除所有模拟数据 |
| 接口对接完成后 | 执行"接口对接后验证清单" |
| 验证通过后 | 检查是否需要更新 plan 文档 |

---

## 常见问题处理

### Q1: 为什么要先用 Newman 测试接口？

**A**: 
- 接口文档可能与实际返回不一致
- 实际字段类型可能与文档描述不同
- 嵌套结构的实际层级可能与文档不同
- 先测试可以避免创建 Model 后需要大量修改

### Q2: 接口字段名与 Swift 命名规范不一致？

**A**: 使用 `CodingKeys` 枚举进行字段映射（见"Model 创建规范"）。

### Q3: 接口返回的数据结构复杂，如何组织 Model？

**A**: 
- 嵌套对象创建独立的 Model
- 使用组合方式组织复杂结构
- 搜索项目中现有 Model 的实现方式，参考其组织方式

### Q4: 项目中找不到网络请求基类？

**A**: 
- 搜索 `Request`、`Network`、`API` 等关键词
- 查看现有页面的网络请求实现方式
- 如果确实没有，可以询问项目负责人或查看项目文档

### Q5: 如何处理接口返回的错误码？

**A**: 
- 使用项目统一的错误处理机制
- 错误码映射到用户友好的错误信息
- 区分网络错误和业务错误

### Q6: 接口对接后 UI 显示异常？

**A**: 
- 检查数据绑定逻辑是否正确
- 检查字段映射是否正确
- 检查数据类型是否匹配
- 检查空值处理是否完善

---

## 最佳实践

1. **先测试，再实现**：使用 Newman 测试接口，了解实际数据格式后再创建 Model
2. **先理解，再实现**：充分理解接口文档和实际响应后再开始编码
3. **复用优先**：优先复用项目现有的架构和工具
4. **状态完整**：确保四种状态（Loading、Success、Error、Empty）都正确处理
5. **清理彻底**：模拟数据切换后，彻底清理模拟代码
6. **测试充分**：对接完成后，充分测试各种场景
7. **文档同步**：及时更新 plan 文档（如需要）
