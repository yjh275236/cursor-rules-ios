---
alwaysApply: false
---

# Serena Memories 维护指南

本规则用于指导 AI 如何构建、更新和维护 Serena MCP 的 memory 文件。**仅在用户明确请求时使用此规则**。

---

## 📋 规则总览（AI 必读）

### 核心原则
1. **智能优先**：用户引用 `@serena-maintenance` 时，立即执行自动评估
2. **强制执行**：不询问用户，直接根据评估结果执行操作
3. **标准输出**：使用统一格式输出评估结果和执行详情
4. **用户可中断**：用户明确指定操作时，跳过自动评估

### 快速导航
- [🎯 强制执行条件](#-强制执行条件) - 何时触发自动评估
- [🤖 智能自动评估流程](#-智能自动评估流程强制执行) - 4 步执行流程
- [📏 评估标准阈值](#-评估标准阈值) - 文件大小、数量、质量评分
- [📖 使用示例](#-使用示例和快速参考) - 智能模式 vs 手动模式
- [🛠️ 具体操作指南](#构建流程) - 构建、更新、审计、精简

### 执行检查清单（AI 自我验证）

在执行自动评估时，AI 必须确认：
- [ ] 是否调用了 `list_memories`？
- [ ] 是否读取了所有 memory 文件？
- [ ] 是否统计了每个文件的行数？
- [ ] 是否计算了质量评分？
- [ ] 是否按照决策树判断了操作？
- [ ] 是否使用了标准输出格式？
- [ ] 是否立即执行了决策的操作（未询问用户）？

**如果任一项未完成，停止并重新执行。**

## 🎯 强制执行条件

当用户输入以下**任一**方式时，**必须立即**执行自动评估流程：

### 触发方式
1. 单独引用 `@serena-maintenance` 或 `@serena-maintenance.mdc`（无其他说明）
2. 引用规则中的"智能使用模式"部分

### ⏸️ 用户中断机制（跳过自动评估）

如果用户**明确指定**了操作，则跳过自动评估，直接执行指定操作：

**触发中断的关键词**：
- "只" + 操作词（如："只审计"，"只更新"，"只精简"）
- "直接" + 操作词
- 明确的操作指令（如："更新 tech_stack.md 添加 Alamofire"）

**示例**：
```
@serena-maintenance 只更新 tech_stack.md，添加 Alamofire
→ 跳过自动评估，直接执行更新操作

@serena-maintenance
→ 执行完整的自动评估流程
```

---

## 🤖 智能自动评估流程（强制执行）

当未触发中断机制时，**必须**按以下顺序执行：

### 步骤 1: 检查现状（必须）

```
1. 调用 mcp_serena-{项目名}_list_memories
2. 读取所有 memory 文件内容
3. 统计每个文件的行数
4. 分析用户消息中的关键词
```

### 步骤 2: 智能决策（必须）

按照以下决策树自动判断操作：

```
检查 memories
│
├─ 无 memories ─────────────────────→ 执行"构建"
│
├─ 文件数 > 5 ─────────────────────→ 执行"精简"
│   或单文件 > 600 行
│
├─ 单文件 500-600 行 ───────────────→ 执行"审计"
│   或有 3+ 处重复内容
│
├─ 用户消息提到变更关键词 ──────────→ 执行"更新"
│   （添加、修改、新增、变更等）
│
└─ 其他情况（状态良好）─────────────→ 执行"报告"
```

**变更关键词列表**：
- 添加、新增、增加、引入
- 修改、变更、更新、调整
- 删除、移除
- 库、依赖、框架、SDK
- 架构、模式、结构

### 步骤 3: 标准输出（必须）

执行自动评估后，**必须**按以下格式输出：

```markdown
✅ 已执行自动评估

## 📊 评估结果
- **文件数量**: X 个
- **文件大小**: 
  - project_overview.md: XXX 行
  - tech_stack.md: XXX 行
  - common_patterns.md: XXX 行
- **重复内容**: X 处
- **质量评分**: XX/100

## 🎯 决策结果
**执行操作**: [构建/更新/审计/精简/报告]

**决策原因**: [简要说明为什么选择此操作]

## 🛠️ 执行详情
[具体执行的内容]

## 💡 改进建议（可选）
[如果有改进建议则列出]
```

### 步骤 4: 执行操作（必须）

根据决策结果立即执行对应操作，**禁止**询问用户是否执行

---

## 📏 评估标准阈值

AI 在执行自动评估时，必须使用以下明确的阈值标准：

### 文件大小阈值

| 状态 | 行数范围 | 处理方式 |
|------|---------|---------|
| ✅ **正常** | < 500 行 | 无需处理 |
| ⚠️ **警告** | 500-600 行 | 执行"审计"，建议精简 |
| ❌ **过大** | > 600 行 | 执行"精简"，必须拆分或精简 |

### 文件数量阈值

| 项目规模 | 源文件数 | 推荐 memory 数量 | 状态 |
|---------|---------|----------------|------|
| **小型项目** | < 50 | 1-2 个 | ✅ 正常 |
| **中型项目** | 50-200 | 2-4 个 | ✅ 正常 |
| **大型项目** | > 200 | 3-5 个 | ⚠️ 需注意 |
| **任何项目** | 任意 | > 5 个 | ❌ 过多，执行"精简" |

### 重复内容阈值

| 重复程度 | 描述 | 状态 |
|---------|------|------|
| ✅ **无重复** | 0 处相似内容 | 正常 |
| ⚠️ **轻微重复** | 1-2 处相似代码示例 | 可接受 |
| ❌ **严重重复** | 3+ 处相似内容 | 执行"审计"或"精简" |

### 质量评分标准（总分 100）

评分维度（AI 必须计算）：
- **内容准确性**（30 分）：信息是否准确、最新、来自实际项目
- **结构组织**（25 分）：文件职责是否清晰、大小是否合理
- **实用性**（25 分）：代码示例是否可运行、说明是否清晰
- **无重复性**（20 分）：是否避免了与其他文件或 Cursor rules 的重复

| 评分范围 | 状态 | 建议操作 |
|---------|------|---------|
| 90-100 分 | 🌟 优秀 | 提供"报告" |
| 70-89 分 | ✅ 良好 | 提供"报告" + 改进建议 |
| 50-69 分 | ⚠️ 需改进 | 执行"审计" |
| < 50 分 | ❌ 较差 | 执行"精简"或"重建" |

---

## Memory 文件结构规范

### 推荐的文件数量

根据项目规模选择合适的文件数量：

**小型项目**（< 50 个源文件）:
- **1-2 个文件**
- `project_overview.md` （必须）
- 根据需要选择 1 个推荐文件

**中型项目**（50-200 个源文件）:
- **2-4 个文件**（推荐）
- `project_overview.md` （必须）
- 从推荐文件中选择 2-3 个

**大型项目**（> 200 个源文件）:
- **3-5 个文件**（上限）
- 核心文件 + 按业务模块拆分

**重要原则**:
- ⚠️ 文件数量不超过 5 个（避免碎片化）
- ⚠️ 单个文件不超过 500 行（警告线）、600 行（红线）
- ⚠️ 优先合并相关内容，而非拆分

### 标准文件清单

#### 1. project_overview.md（必须）

**用途**: 项目概览，优先级最高，新对话时首先读取

**推荐大小**: 100-200 行

**标准模板**:
```markdown
# 项目概览

## 项目基本信息
- **项目名称**: [项目名称]
- **Bundle ID**: [Bundle ID]
- **项目目的**: [简要描述项目用途和目标用户]
- **最低支持版本**: iOS XX.0
- **开发语言**: Swift
- **当前版本**: [版本号]

## 技术栈概览
- **开发语言**: Swift
- **UI 框架**: UIKit / SwiftUI
- **架构模式**: MVC / MVVM / VIPER
- **依赖管理**: CocoaPods / SPM / Carthage
- **核心第三方库**: 
  - Alamofire - 网络请求
  - Kingfisher - 图片加载
  - SnapKit - 自动布局
  （列出 5-10 个最重要的库）

## 目录结构
```
ProjectName/
├── AppDelegate.swift
├── Models/              # 数据模型
├── Views/               # UI 组件
├── Controllers/         # 视图控制器
├── Services/            # 业务逻辑
├── Utilities/           # 工具类
└── Resources/           # 资源文件
```

## 核心架构

### 基类说明
- **BaseViewController**: 所有 VC 的基类，处理通用导航栏配置
- **BaseViewModel**: MVVM 架构的 ViewModel 基类
- **BaseService**: 服务层基类

### 全局配置
- **AppConfig**: 存储 API 域名、Bundle ID 等配置
- **UserManager**: 用户状态管理

### 数据存储
- **本地存储**: UserDefaults / CoreData / Realm
- **缓存策略**: 内存缓存 + 磁盘缓存
- **敏感数据**: Keychain

## 开发环境

### 构建和运行
1. 安装依赖: `pod install` / `swift package resolve`
2. 打开工作空间: `ProjectName.xcworkspace`
3. 选择目标设备运行

### 必要配置
- Firebase 配置文件
- API 密钥配置
- 第三方 SDK 初始化

## 关键约定
- 类名前缀: [如 MyApp]
- 网络请求基类: [如 BaseRequest]
- 响应模型解析: [如使用 Codable]
```

---

#### 2. tech_stack.md（推荐）

**用途**: 详细记录技术栈和第三方库的使用

**推荐大小**: 200-400 行

**标准模板**:
```markdown
# 技术栈详情

## 第三方库列表

### Alamofire - 网络请求库

**用途**: HTTP 网络请求

**官方文档**: https://github.com/Alamofire/Alamofire

**项目中的使用**:
```swift
import Alamofire

class NetworkManager {
    static let shared = NetworkManager()
    
    func request<T: Codable>(
        _ endpoint: String,
        method: HTTPMethod = .get,
        parameters: Parameters? = nil
    ) async throws -> T {
        let response = try await AF.request(
            endpoint,
            method: method,
            parameters: parameters
        ).serializingDecodable(T.self).value
        
        return response
    }
}
```

**注意事项**:
- 使用单例模式管理网络请求
- 统一处理错误和响应
- 配置请求拦截器

---

### Kingfisher - 图片加载

**用途**: 异步图片下载和缓存

**官方文档**: https://github.com/onevcat/Kingfisher

**项目中的使用**:
```swift
import Kingfisher

imageView.kf.setImage(
    with: URL(string: imageURL),
    placeholder: UIImage(named: "placeholder"),
    options: [
        .transition(.fade(0.3)),
        .cacheOriginalImage
    ]
)
```

**配置**:
```swift
// AppDelegate 中配置
let cache = ImageCache.default
cache.memoryStorage.config.totalCostLimit = 100 * 1024 * 1024 // 100 MB
cache.diskStorage.config.sizeLimit = 500 * 1024 * 1024 // 500 MB
```

---

### SnapKit - 自动布局

**用途**: 声明式自动布局 DSL

**官方文档**: https://github.com/SnapKit/SnapKit

**项目中的使用**:
```swift
import SnapKit

private func setupUI() {
    view.addSubview(titleLabel)
    view.addSubview(submitButton)
    
    titleLabel.snp.makeConstraints { make in
        make.top.equalTo(view.safeAreaLayoutGuide).offset(20)
        make.left.right.equalToSuperview().inset(16)
    }
    
    submitButton.snp.makeConstraints { make in
        make.centerX.equalToSuperview()
        make.bottom.equalTo(view.safeAreaLayoutGuide).offset(-30)
        make.width.equalTo(200)
        make.height.equalTo(44)
    }
}
```

---

## Firebase 集成

### Firebase Analytics
- **用途**: 用户行为分析
- **事件追踪**: 登录、购买、页面浏览等
- **配置**: GoogleService-Info.plist

### Firebase Crashlytics
- **用途**: 崩溃报告
- **注意**: 不要上传敏感信息到崩溃日志

### Firebase Cloud Messaging
- **用途**: 推送通知
- **配置步骤**: 
  1. 配置 APNs 证书
  2. 在 AppDelegate 注册推送
  3. 实现 UNUserNotificationCenterDelegate

## 依赖管理

### CocoaPods
**Podfile 示例**:
```ruby
platform :ios, '14.0'
use_frameworks!

target 'ProjectName' do
  pod 'Alamofire', '~> 5.8'
  pod 'Kingfisher', '~> 7.10'
  pod 'SnapKit', '~> 5.7'
  pod 'Firebase/Analytics'
  pod 'Firebase/Crashlytics'
end
```

**常用命令**:
```bash
pod install           # 安装依赖
pod update            # 更新所有依赖
pod update [PodName]  # 更新特定依赖
pod outdated          # 查看过期依赖
```

### Swift Package Manager
**常用操作**:
- File → Add Package Dependencies
- 输入 GitHub 仓库 URL
- 选择版本规则

```

---

#### 3. common_patterns.md（推荐）

**用途**: 项目中常用的代码模式和最佳实践

**推荐大小**: 300-500 行

**标准模板**:
```markdown
# 常用代码模式

## 网络请求模式

### 使用 async/await（推荐）

```swift
// 定义 API Service
class UserService {
    static let shared = UserService()
    
    func fetchUserInfo(userId: Int) async throws -> User {
        let url = "\(APIConfig.baseURL)/users/\(userId)"
        let (data, _) = try await URLSession.shared.data(from: URL(string: url)!)
        return try JSONDecoder().decode(User.self, from: data)
    }
}

// 使用
Task {
    do {
        let user = try await UserService.shared.fetchUserInfo(userId: 123)
        updateUI(with: user)
    } catch {
        showError(error)
    }
}
```

### 使用 Combine

```swift
import Combine

class UserViewModel: ObservableObject {
    @Published var user: User?
    @Published var isLoading = false
    
    private var cancellables = Set<AnyCancellable>()
    
    func loadUser(userId: Int) {
        isLoading = true
        
        UserService.shared.fetchUserPublisher(userId: userId)
            .receive(on: DispatchQueue.main)
            .sink { [weak self] completion in
                self?.isLoading = false
                if case .failure(let error) = completion {
                    // 处理错误
                }
            } receiveValue: { [weak self] user in
                self?.user = user
            }
            .store(in: &cancellables)
    }
}
```

---

## UI 组件创建模式

### UIKit + SnapKit

```swift
class CustomView: UIView {
    // MARK: - UI Components
    
    private let titleLabel: UILabel = {
        let label = UILabel()
        label.font = .systemFont(ofSize: 18, weight: .bold)
        label.textColor = .black
        return label
    }()
    
    private lazy var actionButton: UIButton = {
        let button = UIButton(type: .system)
        button.setTitle("确认", for: .normal)
        button.addTarget(self, action: #selector(handleAction), for: .touchUpInside)
        return button
    }()
    
    // MARK: - Initialization
    
    override init(frame: CGRect) {
        super.init(frame: frame)
        setupUI()
    }
    
    required init?(coder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    // MARK: - UI Setup
    
    private func setupUI() {
        addSubview(titleLabel)
        addSubview(actionButton)
        
        titleLabel.snp.makeConstraints { make in
            make.top.equalToSuperview().offset(20)
            make.left.right.equalToSuperview().inset(16)
        }
        
        actionButton.snp.makeConstraints { make in
            make.top.equalTo(titleLabel.snp.bottom).offset(20)
            make.centerX.equalToSuperview()
            make.width.equalTo(120)
            make.height.equalTo(44)
        }
    }
    
    // MARK: - Actions
    
    @objc private func handleAction() {
        // 处理按钮点击
    }
}
```

### SwiftUI

```swift
struct UserProfileView: View {
    @StateObject private var viewModel = UserProfileViewModel()
    
    var body: some View {
        VStack(spacing: 20) {
            if viewModel.isLoading {
                ProgressView()
            } else if let user = viewModel.user {
                AsyncImage(url: URL(string: user.avatarURL)) { image in
                    image.resizable()
                } placeholder: {
                    Color.gray
                }
                .frame(width: 100, height: 100)
                .clipShape(Circle())
                
                Text(user.name)
                    .font(.title)
                
                Button("编辑") {
                    viewModel.editUser()
                }
            }
        }
        .task {
            await viewModel.loadUser()
        }
    }
}
```

---

## 数据处理模式

### JSON 解析（Codable）

```swift
// 定义模型
struct User: Codable {
    let id: Int
    let name: String
    let email: String
    let avatarURL: String?
    
    enum CodingKeys: String, CodingKey {
        case id
        case name
        case email
        case avatarURL = "avatar_url"
    }
}

// 解析
let decoder = JSONDecoder()
decoder.keyDecodingStrategy = .convertFromSnakeCase
let user = try decoder.decode(User.self, from: data)

// 编码
let encoder = JSONEncoder()
encoder.keyEncodingStrategy = .convertToSnakeCase
let data = try encoder.encode(user)
```

### 本地存储（UserDefaults）

```swift
extension UserDefaults {
    private enum Keys {
        static let userToken = "userToken"
        static let isFirstLaunch = "isFirstLaunch"
    }
    
    var userToken: String? {
        get { string(forKey: Keys.userToken) }
        set { set(newValue, forKey: Keys.userToken) }
    }
    
    var isFirstLaunch: Bool {
        get { bool(forKey: Keys.isFirstLaunch) }
        set { set(newValue, forKey: Keys.isFirstLaunch) }
    }
}
```

### Keychain 存储（敏感数据）

```swift
import Security

class KeychainManager {
    static let shared = KeychainManager()
    
    func save(_ value: String, forKey key: String) -> Bool {
        guard let data = value.data(using: .utf8) else { return false }
        
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrAccount as String: key,
            kSecValueData as String: data
        ]
        
        SecItemDelete(query as CFDictionary)
        return SecItemAdd(query as CFDictionary, nil) == errSecSuccess
    }
    
    func get(forKey key: String) -> String? {
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrAccount as String: key,
            kSecReturnData as String: true
        ]
        
        var result: AnyObject?
        let status = SecItemCopyMatching(query as CFDictionary, &result)
        
        guard status == errSecSuccess,
              let data = result as? Data,
              let string = String(data: data, encoding: .utf8) else {
            return nil
        }
        
        return string
    }
}
```

---

## 错误处理模式

### 自定义错误类型

```swift
enum AppError: LocalizedError {
    case networkError(String)
    case dataParsingError
    case unauthorized
    case unknown
    
    var errorDescription: String? {
        switch self {
        case .networkError(let message):
            return "网络错误: \(message)"
        case .dataParsingError:
            return "数据解析失败"
        case .unauthorized:
            return "未授权，请重新登录"
        case .unknown:
            return "未知错误"
        }
    }
}
```

### 统一错误处理

```swift
extension UIViewController {
    func handleError(_ error: Error) {
        let message: String
        
        if let appError = error as? AppError {
            message = appError.errorDescription ?? "未知错误"
        } else {
            message = error.localizedDescription
        }
        
        showAlert(title: "错误", message: message)
    }
    
    private func showAlert(title: String, message: String) {
        let alert = UIAlertController(
            title: title,
            message: message,
            preferredStyle: .alert
        )
        alert.addAction(UIAlertAction(title: "确定", style: .default))
        present(alert, animated: true)
    }
}
```

---

## MVVM 架构模式

```swift
// Model
struct Product: Codable {
    let id: Int
    let name: String
    let price: Double
}

// ViewModel
class ProductListViewModel: ObservableObject {
    @Published var products: [Product] = []
    @Published var isLoading = false
    @Published var errorMessage: String?
    
    private let service: ProductService
    
    init(service: ProductService = ProductService.shared) {
        self.service = service
    }
    
    func loadProducts() async {
        isLoading = true
        errorMessage = nil
        
        do {
            products = try await service.fetchProducts()
        } catch {
            errorMessage = error.localizedDescription
        }
        
        isLoading = false
    }
}

// View (SwiftUI)
struct ProductListView: View {
    @StateObject private var viewModel = ProductListViewModel()
    
    var body: some View {
        List(viewModel.products, id: \.id) { product in
            HStack {
                Text(product.name)
                Spacer()
                Text("$\(product.price, specifier: "%.2f")")
            }
        }
        .task {
            await viewModel.loadProducts()
        }
    }
}
```
```

---

#### 4. architecture.md（可选，复杂项目）

**用途**: 详细的架构设计说明

**推荐大小**: 200-400 行

**适用场景**:
- 使用复杂架构模式（VIPER、Clean Architecture）
- 有明确的分层设计
- 需要详细说明模块间通信

---

#### 5. api_guide.md（可选，API 密集型项目）

**用途**: API 使用指南和文档

**推荐大小**: 200-400 行

**适用场景**:
- RESTful API 较多
- 有复杂的认证流程
- 需要记录 API 端点和参数

---

## 构建流程

### 从头构建 Memories

当用户请求 `@serena-maintenance 从头构建项目 memories` 时：

**步骤 1: 评估项目规模**
1. 使用 `mcp_serena_list_dir` 查看项目结构
2. 统计源文件数量
3. 根据规模确定文件数量（1-5 个）

**步骤 2: 收集项目信息**
1. 读取 `Podfile` / `Package.swift` 了解依赖
2. 读取 `Info.plist` 了解基本配置
3. 查看主要源文件了解架构模式
4. 分析目录结构

**步骤 3: 优先创建 project_overview.md**
1. 项目基本信息
2. 技术栈概览（5-10 个核心库）
3. 简化的目录结构
4. 核心架构说明
5. 关键约定（如类前缀、基类等）

**步骤 4: 根据需要创建其他文件**

**创建 tech_stack.md** 当:
- 使用了 5+ 个第三方库
- 库的配置较复杂
- 有特定的使用模式

**创建 common_patterns.md** 当:
- 有统一的代码模式
- 网络请求、UI 创建有特定规范
- 有自定义的架构实现

**步骤 5: 验证和优化**
1. 确保每个文件内容完整
2. 检查文件大小（< 500 行）
3. 验证代码示例来自实际项目
4. 确保没有与 Cursor rules 重复

---

### 更新现有 Memories

**步骤 1: 评估变更**
1. 使用 `mcp_serena_list_memories` 查看现有文件
2. 确定需要更新的文件
3. 读取相关文件了解当前内容

**步骤 2: 收集新信息**
1. 从代码中提取实际示例
2. 询问用户具体变更
3. 检查新增的依赖或架构变化

**步骤 3: 更新内容**
1. 使用 `mcp_serena_write_memory` 更新
2. 保持原有结构
3. 确保代码示例可运行
4. 验证信息准确性

---

### 审计 Memories 质量

当用户请求审计时，检查以下方面：

**1. 内容质量检查**
- [ ] 信息是否准确和最新
- [ ] 是否有过时的内容
- [ ] 代码示例是否来自实际项目
- [ ] 代码示例是否可运行
- [ ] 是否有重复信息

**2. 结构组织检查**
- [ ] 文件数量是否合理（不超过 5 个）
- [ ] 每个文件职责是否清晰
- [ ] 文件大小是否适中（< 500 行）
- [ ] 标题层级是否清晰
- [ ] 是否有过度碎片化

**3. 与 Cursor Rules 的关系**
- [ ] 是否有应该在 Cursor rules 的内容
- [ ] 是否有与 Cursor rules 重复的内容
- [ ] 是否有通用规范混入项目特定信息

**4. 可用性检查**
- [ ] 文件名是否描述性强
- [ ] 是否容易找到需要的信息
- [ ] 代码示例是否实用
- [ ] 说明是否清晰

---

### 精简 Memories

当 memories 内容过多或冗余时：

**步骤 1: 识别问题**
- 文件数量过多（> 5 个）
- 单个文件过大（> 500 行）
- 有重复内容
- 有通用内容（应该在 Cursor rules）

**步骤 2: 合并策略**
- 将相关小文件合并（如 api_guide 合并到 tech_stack）
- 提取通用内容到 Cursor rules
- 删除过时内容
- 精简冗长的解释

**步骤 3: 重组**
- 按照标准模板重新组织
- 确保符合推荐的文件数量
- 保持关键信息不丢失
- 验证代码示例仍然有效

---

## 更新触发场景

### 必须更新的情况
- ✅ 项目结构发生重大变化
- ✅ 添加或删除了重要的第三方库
- ✅ 架构模式发生变化
- ✅ API 基础配置变更

### 建议更新的情况
- ⚠️ 发现了新的最佳实践
- ⚠️ 解决了重要的技术问题
- ⚠️ 常用代码模式有变化
- ⚠️ 定期维护（如季度审计）

### 不需要更新的情况
- ❌ 小的代码修改
- ❌ 临时的调试信息
- ❌ 单个 bug 修复
- ❌ UI 样式微调

---

## 质量标准

### 内容要求
- ✅ 使用 Markdown 格式
- ✅ 清晰的标题层级（# ## ###）
- ✅ 包含实用的代码示例
- ✅ 代码示例来自实际项目，可运行
- ✅ 突出重要信息（使用粗体、引用等）
- ❌ 避免与 Cursor rules 重复
- ❌ 避免记录通用知识（Swift 语法等）
- ❌ 避免过度详细的注释

### 结构要求
- ✅ 每个文件有清晰的用途
- ✅ 章节组织合理
- ✅ 使用代码块标注语言
- ✅ 使用列表、表格提高可读性

### 大小控制
- ✅ 单个文件 < 500 行
- ✅ 总文件数 ≤ 5 个
- ✅ `project_overview.md` < 200 行

---

## 📖 使用示例和快速参考

### 智能模式（推荐）- 自动评估

用户只需引用规则，AI 自动评估并执行：

```
用户: @serena-maintenance
```

AI 自动执行：
1. ✅ 读取所有 memories
2. 📊 评估状态（文件数量、大小、重复内容）
3. 🎯 决策操作（构建/更新/审计/精简/报告）
4. 🛠️ 立即执行
5. 📝 输出标准格式报告

### 手动模式 - 明确指定操作

用户明确指定操作时，跳过自动评估：

#### 完整重建
```
@serena-maintenance 从头构建项目 memories
@serena-maintenance 只构建
```
AI 将：分析项目 → 创建标准文件 → 填充内容 → 验证质量

#### 更新特定文件
```
@serena-maintenance 更新 tech_stack.md，我添加了 Alamofire
@serena-maintenance 只更新 common_patterns，添加新的网络请求模式
```
AI 将：读取文件 → 添加新内容 → 更新文件

#### 质量审计
```
@serena-maintenance 审计现有 memories 的质量
@serena-maintenance 只审计
```
AI 将：检查所有 memories → 识别问题 → 提供改进建议

#### 精简优化
```
@serena-maintenance 精简 memories，删除冗余内容
@serena-maintenance 只精简
```
AI 将：分析内容 → 合并相关文件 → 删除冗余 → 重新组织

#### 检查过时内容
```
@serena-maintenance 检查 memories 是否过时
```
AI 将：对比代码 → 识别过时信息 → 更新内容

#### 状态报告
```
@serena-maintenance 生成状态报告
@serena-maintenance 只报告
```
AI 将：分析当前状态 → 生成详细报告 → 提供建议

---

## 🔄 执行流程对比

### 智能模式 vs 手动模式

| 维度 | 智能模式 | 手动模式 |
|------|---------|---------|
| **触发** | `@serena-maintenance` | `@serena-maintenance 只[操作]` |
| **评估** | ✅ 自动执行 | ❌ 跳过评估 |
| **决策** | 🤖 AI 自动判断 | 👤 用户指定 |
| **速度** | 稍慢（需评估） | 快速（直接执行） |
| **适用场景** | 不确定需要什么操作 | 明确知道要做什么 |
| **推荐度** | ⭐⭐⭐⭐⭐ 推荐 | ⭐⭐⭐ 特定场景 |

---

## 最佳实践

### DO ✅
- ✅ 定期审计 memories（建议每季度或重大更新后）
- ✅ 保持文件数量精简（1-5 个）
- ✅ 使用标准模板确保一致性
- ✅ 代码示例来自实际项目
- ✅ 及时更新重要变更
- ✅ 使用智能模式（`@serena-maintenance`）让 AI 自动判断

### DON'T ❌
- ❌ 不要创建过多碎片化文件
- ❌ 不要在 memory 中记录通用知识
- ❌ 不要与 Cursor rules 重复
- ❌ 不要让单个文件过大（> 600 行红线）
- ❌ 不要记录临时信息
- ❌ 不要在自动评估模式下询问用户

---

## ❓ 常见问题

### Q1: 什么时候使用智能模式，什么时候使用手动模式？

**A**: 
- **智能模式**（推荐）：不确定需要什么操作时，让 AI 自动评估
  ```
  @serena-maintenance
  ```
- **手动模式**：明确知道要做什么时，直接指定操作
  ```
  @serena-maintenance 只更新 tech_stack.md
  ```

### Q2: AI 如何判断应该执行哪个操作？

**A**: AI 按照以下优先级顺序判断：
1. 无 memories → 构建
2. 文件数 > 5 或单文件 > 600 行 → 精简
3. 单文件 500-600 行或重复 3+ 处 → 审计
4. 用户消息提到变更关键词 → 更新
5. 其他情况 → 报告

### Q3: 质量评分是如何计算的？

**A**: 质量评分基于 4 个维度，总分 100：
- 内容准确性（30 分）
- 结构组织（25 分）
- 实用性（25 分）
- 无重复性（20 分）

### Q4: 为什么文件大小限制是 500-600 行？

**A**: 
- **< 500 行**：理想大小，AI 可以快速读取和理解
- **500-600 行**：警告区，建议精简但可接受
- **> 600 行**：红线，必须拆分或精简，影响 AI 处理效率

### Q5: 什么内容应该放在 Cursor rules，什么放在 Serena memories？

**A**:
- **Cursor Rules**：通用编码规范、跨项目偏好、工作流程
- **Serena Memories**：项目特定信息、技术栈、代码模式

### Q6: 如何判断内容是否重复？

**A**: 重复内容包括：
- 相同的代码示例出现在多个文件
- 相同的库介绍在多处重复
- 与 Cursor rules 重复的通用规范

### Q7: 自动评估会修改我的 memories 吗？

**A**: 
- **智能模式**：会根据评估结果自动执行操作（可能修改）
- **手动模式**：只有你明确指定操作才会修改
- **报告模式**：只提供建议，不修改

### Q8: 多久应该审计一次 memories？

**A**: 建议时机：
- ✅ 每季度定期审计
- ✅ 重大架构变更后
- ✅ 添加 5+ 个新库后
- ✅ 项目规模显著变化后

---

## 📝 版本更新日志

### v2.0 (2025-10-30) - 智能化升级
**新增**：
- ✨ 智能自动评估流程
- ✨ 明确的评估标准阈值
- ✨ 质量评分系统（100 分制）
- ✨ 用户中断机制
- ✨ 标准输出格式
- ✨ 决策树可视化
- ✨ 执行检查清单
- ✨ 快速导航
- ✨ 常见问题解答

**改进**：
- 🔧 将"推荐"改为"强制"执行
- 🔧 添加具体的数值阈值
- 🔧 完善使用示例
- 🔧 增强操作流程说明

**修复**：
- 🐛 修复 AI 不自动执行的问题
- 🐛 明确何时询问用户、何时自动执行

### v1.0 (初始版本)
- 基础的 memory 维护指南
- 文件结构规范
- 构建、更新、审计流程

---

**重要提醒**: 本规则仅在用户明确请求时使用。日常开发使用 `01-serena-workflow.mdc` 规则。
