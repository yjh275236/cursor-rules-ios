---
alwaysApply: false
---

# Serena Memories 维护指南

## ⚠️ 重要区分（AI 必读）

**本规则用途**：构建、更新、维护 Serena Memories（管理 memory 文件本身）

**与日常工作流的区别**：
- 📖 **日常开发** → 使用 `01-serena-workflow.mdc`（读取和使用 memories）
- 🛠️ **维护 memories** → 使用本规则（管理 memory 文件）

**触发方式**：**仅在用户明确请求 `@serena-maintenance` 时使用**

---

## 📋 规则总览（AI 必读）

### 核心原则
1. **智能优先**：用户引用 `@serena-maintenance` 时，立即执行自动评估
2. **强制执行**：不询问用户，直接根据评估结果执行操作
3. **标准输出**：使用统一格式输出评估结果和执行详情
4. **用户可中断**：用户明确指定操作时，跳过自动评估

### 快速导航
- [🎯 强制执行条件](#-强制执行条件) - 何时触发自动评估
- [🤖 智能自动评估流程](#-智能自动评估流程强制执行) - 4 步执行流程
- [📏 评估标准阈值](#-评估标准阈值) - 文件大小、数量、质量评分
- [📖 使用示例](#-使用示例和快速参考) - 智能模式 vs 手动模式
- [🛠️ 具体操作指南](#构建流程) - 构建、更新、审计、精简

### 执行检查清单（AI 自我验证）

在执行自动评估时，AI 必须确认：
- [ ] 是否调用了 `list_memories`？
- [ ] 是否读取了所有 memory 文件？
- [ ] 是否统计了每个文件的行数？
- [ ] 是否计算了质量评分？
- [ ] 是否按照决策树判断了操作？
- [ ] 是否使用了标准输出格式？
- [ ] 是否立即执行了决策的操作（未询问用户）？

**如果任一项未完成，停止并重新执行。**

## 🎯 强制执行条件

当用户输入以下**任一**方式时，**必须立即**执行自动评估流程：

### 触发方式
1. 单独引用 `@serena-maintenance` 或 `@serena-maintenance.mdc`（无其他说明）
2. 引用规则中的"智能使用模式"部分

### ⏸️ 用户中断机制（跳过自动评估）

如果用户**明确指定**了操作，则跳过自动评估，直接执行指定操作：

**触发中断的关键词**：
- "只" + 操作词（如："只审计"，"只更新"，"只精简"）
- "直接" + 操作词
- 明确的操作指令（如："更新 tech_stack.md 添加 Alamofire"）

**示例**：
```
@serena-maintenance 只更新 tech_stack.md，添加 Alamofire
→ 跳过自动评估，直接执行更新操作

@serena-maintenance
→ 执行完整的自动评估流程
```

---

## 🤖 智能自动评估流程（强制执行）

当未触发中断机制时，**必须**按以下顺序执行：

### 步骤 1: 检查现状（必须）

```
1. 调用 mcp_serena-{项目名}_list_memories
2. 读取所有 memory 文件内容
3. 统计每个文件的行数
4. 分析用户消息中的关键词
```

### 步骤 2: 智能决策（必须）

按照以下决策树自动判断操作：

```
检查 memories
│
├─ 无 memories ─────────────────────→ 执行"构建"
│
├─ 文件数 > 5 ─────────────────────→ 执行"精简"
│   或单文件 > 600 行
│
├─ 单文件 500-600 行 ───────────────→ 执行"审计"
│   或有 3+ 处重复内容
│
├─ 用户消息提到变更关键词 ──────────→ 执行"更新"
│   （添加、修改、新增、变更等）
│
└─ 其他情况（状态良好）─────────────→ 执行"报告"
```

**变更关键词列表**：
- 添加、新增、增加、引入
- 修改、变更、更新、调整
- 删除、移除
- 库、依赖、框架、SDK
- 架构、模式、结构

### 步骤 3: 标准输出（必须）

执行自动评估后，**必须**按以下格式输出：

```markdown
✅ 已执行自动评估

## 📊 评估结果
- **文件数量**: X 个
- **文件大小**: 
  - project_overview.md: XXX 行
  - tech_stack.md: XXX 行
  - common_patterns.md: XXX 行
- **重复内容**: X 处
- **质量评分**: XX/100

## 🎯 决策结果
**执行操作**: [构建/更新/审计/精简/报告]

**决策原因**: [简要说明为什么选择此操作]

## 🛠️ 执行详情
[具体执行的内容]

## 💡 改进建议（可选）
[如果有改进建议则列出]
```

### 步骤 4: 执行操作（必须）

根据决策结果立即执行对应操作，**禁止**询问用户是否执行

---

## 📏 评估标准阈值

AI 在执行自动评估时，必须使用以下明确的阈值标准：

### 文件大小阈值

| 状态 | 行数范围 | 处理方式 |
|------|---------|---------|
| ✅ **正常** | < 500 行 | 无需处理 |
| ⚠️ **警告** | 500-600 行 | 执行"审计"，建议精简 |
| ❌ **过大** | > 600 行 | 执行"精简"，必须拆分或精简 |

### 文件数量阈值

| 项目规模 | 源文件数 | 推荐 memory 数量 | 状态 |
|---------|---------|----------------|------|
| **小型项目** | < 50 | 1-2 个 | ✅ 正常 |
| **中型项目** | 50-200 | 2-4 个 | ✅ 正常 |
| **大型项目** | > 200 | 3-5 个 | ⚠️ 需注意 |
| **任何项目** | 任意 | > 5 个 | ❌ 过多，执行"精简" |

### 重复内容阈值

| 重复程度 | 描述 | 状态 |
|---------|------|------|
| ✅ **无重复** | 0 处相似内容 | 正常 |
| ⚠️ **轻微重复** | 1-2 处相似代码示例 | 可接受 |
| ❌ **严重重复** | 3+ 处相似内容 | 执行"审计"或"精简" |

### 质量评分标准（总分 100）

评分维度（AI 必须计算）：
- **内容准确性**（30 分）：信息是否准确、最新、来自实际项目
- **结构组织**（25 分）：文件职责是否清晰、大小是否合理
- **实用性**（25 分）：代码示例是否可运行、说明是否清晰
- **无重复性**（20 分）：是否避免了与其他文件或 Cursor rules 的重复

| 评分范围 | 状态 | 建议操作 |
|---------|------|---------|
| 90-100 分 | 🌟 优秀 | 提供"报告" |
| 70-89 分 | ✅ 良好 | 提供"报告" + 改进建议 |
| 50-69 分 | ⚠️ 需改进 | 执行"审计" |
| < 50 分 | ❌ 较差 | 执行"精简"或"重建" |

---

## Memory 文件结构规范

### 推荐的文件数量

根据项目规模选择合适的文件数量：

**小型项目**（< 50 个源文件）:
- **1-2 个文件**
- `project_overview.md` （必须）
- 根据需要选择 1 个推荐文件

**中型项目**（50-200 个源文件）:
- **2-4 个文件**（推荐）
- `project_overview.md` （必须）
- 从推荐文件中选择 2-3 个

**大型项目**（> 200 个源文件）:
- **3-5 个文件**（上限）
- 核心文件 + 按业务模块拆分

**重要原则**:
- ⚠️ 文件数量不超过 5 个（避免碎片化）
- ⚠️ 单个文件不超过 500 行（警告线）、600 行（红线）
- ⚠️ 优先合并相关内容，而非拆分

### 标准文件清单

#### 1. project_overview.md（必须）

**用途**: 项目概览，优先级最高，新对话时首先读取

**推荐大小**: 100-200 行

**标准模板**:
```markdown
# 项目概览

## 项目基本信息
- **项目名称**: [项目名称]
- **Bundle ID**: [Bundle ID]
- **项目目的**: [简要描述项目用途和目标用户]
- **最低支持版本**: iOS XX.0
- **开发语言**: Swift
- **当前版本**: [版本号]

## 技术栈概览
- **开发语言**: Swift
- **UI 框架**: UIKit / SwiftUI
- **架构模式**: MVC / MVVM / VIPER
- **依赖管理**: CocoaPods / SPM / Carthage
- **核心第三方库**: 
  - Alamofire - 网络请求
  - Kingfisher - 图片加载
  - SnapKit - 自动布局
  （列出 5-10 个最重要的库）

## 目录结构
```
ProjectName/
├── AppDelegate.swift
├── Models/              # 数据模型
├── Views/               # UI 组件
├── Controllers/         # 视图控制器
├── Services/            # 业务逻辑
├── Utilities/           # 工具类
└── Resources/           # 资源文件
```

## 核心架构

### 基类说明
- **BaseViewController**: 所有 VC 的基类，处理通用导航栏配置
- **BaseViewModel**: MVVM 架构的 ViewModel 基类
- **BaseService**: 服务层基类

### 全局配置
- **AppConfig**: 存储 API 域名、Bundle ID 等配置
- **UserManager**: 用户状态管理

### 数据存储
- **本地存储**: UserDefaults / CoreData / Realm
- **缓存策略**: 内存缓存 + 磁盘缓存
- **敏感数据**: Keychain

## 开发环境

### 构建和运行
1. 安装依赖: `pod install` / `swift package resolve`
2. 打开工作空间: `ProjectName.xcworkspace`
3. 选择目标设备运行

### 必要配置
- Firebase 配置文件
- API 密钥配置
- 第三方 SDK 初始化

## 关键约定
- 类名前缀: [如 MyApp]
- 网络请求基类: [如 BaseRequest]
- 响应模型解析: [如使用 Codable]
```

---

#### 2. tech_stack.md（推荐）

**用途**: 详细记录技术栈和第三方库的使用

**推荐大小**: 200-400 行

**标准模板**:
```markdown
# 技术栈详情

## 第三方库列表

### Alamofire - 网络请求库

**用途**: HTTP 网络请求

**官方文档**: https://github.com/Alamofire/Alamofire

**项目中的使用**:
```swift
import Alamofire

class NetworkManager {
    static let shared = NetworkManager()
    
    func request<T: Codable>(
        _ endpoint: String,
        method: HTTPMethod = .get,
        parameters: Parameters? = nil
    ) async throws -> T {
        let response = try await AF.request(
            endpoint,
            method: method,
            parameters: parameters
        ).serializingDecodable(T.self).value
        
        return response
    }
}
```

**注意事项**:
- 使用单例模式管理网络请求
- 统一处理错误和响应
- 配置请求拦截器

---

### Kingfisher - 图片加载

**用途**: 异步图片下载和缓存

**官方文档**: https://github.com/onevcat/Kingfisher

**项目中的使用**:
```swift
import Kingfisher

imageView.kf.setImage(
    with: URL(string: imageURL),
    placeholder: UIImage(named: "placeholder"),
    options: [
        .transition(.fade(0.3)),
        .cacheOriginalImage
    ]
)
```

**配置**:
```swift
// AppDelegate 中配置
let cache = ImageCache.default
cache.memoryStorage.config.totalCostLimit = 100 * 1024 * 1024 // 100 MB
cache.diskStorage.config.sizeLimit = 500 * 1024 * 1024 // 500 MB
```

---

### SnapKit - 自动布局

**用途**: 声明式自动布局 DSL

**官方文档**: https://github.com/SnapKit/SnapKit

**项目中的使用**:
```swift
import SnapKit

private func setupUI() {
    view.addSubview(titleLabel)
    view.addSubview(submitButton)
    
    titleLabel.snp.makeConstraints { make in
        make.top.equalTo(view.safeAreaLayoutGuide).offset(20)
        make.left.right.equalToSuperview().inset(16)
    }
    
    submitButton.snp.makeConstraints { make in
        make.centerX.equalToSuperview()
        make.bottom.equalTo(view.safeAreaLayoutGuide).offset(-30)
        make.width.equalTo(200)
        make.height.equalTo(44)
    }
}
```

---

## Firebase 集成

### Firebase Analytics
- **用途**: 用户行为分析
- **事件追踪**: 登录、购买、页面浏览等
- **配置**: GoogleService-Info.plist

### Firebase Crashlytics
- **用途**: 崩溃报告
- **注意**: 不要上传敏感信息到崩溃日志

### Firebase Cloud Messaging
- **用途**: 推送通知
- **配置步骤**: 
  1. 配置 APNs 证书
  2. 在 AppDelegate 注册推送
  3. 实现 UNUserNotificationCenterDelegate

## 依赖管理

### CocoaPods
**Podfile 示例**:
```ruby
platform :ios, '14.0'
use_frameworks!

target 'ProjectName' do
  pod 'Alamofire', '~> 5.8'
  pod 'Kingfisher', '~> 7.10'
  pod 'SnapKit', '~> 5.7'
  pod 'Firebase/Analytics'
  pod 'Firebase/Crashlytics'
end
```

**常用命令**:
```bash
pod install           # 安装依赖
pod update            # 更新所有依赖
pod update [PodName]  # 更新特定依赖
pod outdated          # 查看过期依赖
```

### Swift Package Manager
**常用操作**:
- File → Add Package Dependencies
- 输入 GitHub 仓库 URL
- 选择版本规则

```

---

#### 3. common_patterns.md（推荐）

**用途**: 项目中常用的代码模式和最佳实践

**推荐大小**: 300-500 行

**内容建议**:
- 记录项目特定的代码模式（网络请求、UI 创建、数据处理等）
- 记录架构模式和数据流向
- 只记录"不同寻常"的实现，不记录通用知识
- 代码示例保持简短（< 30 行）

**标准模板**:
```markdown
# 常用代码模式

记录项目中实际使用的代码模式（不记录通用知识）。

## 网络请求模式
[项目特定实现]

## UI 创建模式  
[项目特定实现]

## 数据处理模式
[项目特定实现]

## 架构模式
[项目特定实现]

```

#### 4. api_reference.md（可选）

**用途**: API 端点文档（适用于 RESTful API 较多的项目）

**推荐大小**: 200-400 行

---

## 构建流程

### 从头构建 Memories

当用户请求 `@serena-maintenance 从头构建项目 memories` 时：

**步骤 1: 评估项目规模**
1. 使用 `mcp_serena_list_dir` 查看项目结构
2. 统计源文件数量
3. 根据规模确定文件数量（1-5 个）

**步骤 2: 收集项目信息**
1. 读取 `Podfile` / `Package.swift` 了解依赖
2. 读取 `Info.plist` 了解基本配置
3. 查看主要源文件了解架构模式
4. 分析目录结构

**步骤 3: 创建标准文件**
1. 必须创建：`project_overview.md`
2. 根据项目规模选择创建：`tech_stack.md`, `common_patterns.md`
3. 使用标准模板填充内容

**步骤 4: 验证质量**
使用质量标准检查生成的内容

---

### 更新现有 Memories

当用户请求更新特定 memory 时：

**步骤 1: 读取现有内容**
使用 `mcp_serena_read_memory` 读取目标文件

**步骤 2: 定位更新位置**
找到需要更新的章节或内容

**步骤 3: 更新内容**
使用 `mcp_serena_write_memory` 更新文件

**步骤 4: 验证一致性**
确保更新后的内容与其他 memory 文件保持一致

---

### 审计 Memories 质量

当用户请求审计时：

**执行以下检查**：

1. **大小检查**
   - 单文件 > 600 行 → 标记为"需要精简"
   - 单文件 500-600 行 → 标记为"警告"

2. **重复检查**
   - 检查相同代码示例是否出现在多个文件
   - 检查与 Cursor rules 的内容重复

3. **质量评分**（总分 100）
   - 内容准确性（30 分）
   - 结构组织（25 分）
   - 实用性（25 分）
   - 无重复性（20 分）

4. **输出报告**
   - 列出所有发现的问题
   - 提供改进建议
   - 给出质量评分

---

### 精简 Memories

当文件数 > 5 或单文件 > 600 行时：

**执行策略**：

1. **合并相关内容**
   - 将小文件合并到相关的大文件
   - 例如：将 `api_reference.md` 合并到 `tech_stack.md`

2. **删除冗余**
   - 删除与 Cursor rules 重复的内容
   - 删除通用知识（非项目特定）

3. **精简示例**
   - 缩短过长的代码示例
   - 只保留关键部分

4. **验证结果**
   - 确保精简后文件数 ≤ 5
   - 确保单文件 < 600 行

---

## 更新触发场景

### 必须更新的情况
- 添加了新的重要第三方库
- 项目架构发生重大变更
- 目录结构调整
- 核心约定修改

### 建议更新的情况
- 添加了新的代码模式
- API 端点变更
- 环境配置更新

### 不需要更新的情况
- 小的 bug 修复
- UI 样式微调
- 临时性代码

---

## 质量标准

### 内容要求
- 准确反映项目当前状态
- 使用实际项目中的代码示例
- 避免记录通用知识
- 避免与 Cursor rules 重复

### 结构要求
- 使用标准 Markdown 格式
- 清晰的章节层次
- 适当的代码高亮

### 大小控制
- 文件数量：1-5 个
- 单文件大小：< 500 行（理想），< 600 行（红线）

---

## 📖 使用示例和快速参考

### 智能模式（推荐）- 自动评估

用户只需引用规则，AI 自动评估并执行：

```
用户: @serena-maintenance
```

AI 自动执行：
1. ✅ 读取所有 memories
2. 📊 评估状态（文件数量、大小、重复内容）
3. 🎯 决策操作（构建/更新/审计/精简/报告）
4. 🛠️ 立即执行
5. 📝 输出标准格式报告

### 手动模式 - 明确指定操作

用户明确指定操作时，跳过自动评估：

```bash
# 完整重建
@serena-maintenance 从头构建项目 memories

# 更新特定文件
@serena-maintenance 更新 tech_stack.md，我添加了 Alamofire

# 质量审计
@serena-maintenance 只审计

# 精简优化
@serena-maintenance 只精简
```

---

## 🔄 执行流程对比

### 智能模式 vs 手动模式

| 维度 | 智能模式 | 手动模式 |
|------|---------|---------|
| **触发** | `@serena-maintenance` | `@serena-maintenance 只[操作]` |
| **评估** | ✅ 自动执行 | ❌ 跳过评估 |
| **决策** | 🤖 AI 自动判断 | 👤 用户指定 |
| **速度** | 稍慢（需评估） | 快速（直接执行） |
| **适用场景** | 不确定需要什么操作 | 明确知道要做什么 |
| **推荐度** | ⭐⭐⭐⭐⭐ 推荐 | ⭐⭐⭐ 特定场景 |

---

## 最佳实践

### DO ✅
- ✅ 定期审计 memories（建议每季度或重大更新后）
- ✅ 保持文件数量精简（1-5 个）
- ✅ 使用标准模板确保一致性
- ✅ 代码示例来自实际项目
- ✅ 及时更新重要变更
- ✅ 使用智能模式（`@serena-maintenance`）让 AI 自动判断

### DON'T ❌
- ❌ 不要创建过多碎片化文件
- ❌ 不要在 memory 中记录通用知识
- ❌ 不要与 Cursor rules 重复
- ❌ 不要让单个文件过大（> 600 行红线）
- ❌ 不要记录临时信息
- ❌ 不要在自动评估模式下询问用户

---

## ❓ 常见问题

**Q1: 什么时候使用智能模式？**
- 不确定需要什么操作 → `@serena-maintenance`（智能模式）
- 明确知道要做什么 → `@serena-maintenance 只[操作]`（手动模式）

**Q2: AI 如何判断执行哪个操作？**
1. 无 memories → 构建
2. 文件数 > 5 或单文件 > 600 行 → 精简
3. 单文件 500-600 行或重复 3+ 处 → 审计
4. 用户消息提到变更关键词 → 更新
5. 其他情况 → 报告

**Q3: 文件大小限制？**
- < 500 行：理想 ✅
- 500-600 行：警告 ⚠️
- \> 600 行：红线 ❌

**Q4: Cursor Rules vs Serena Memories？**
- Cursor Rules：通用编码规范、跨项目偏好
- Serena Memories：项目特定信息、技术栈

**Q5: 多久审计一次？**
建议：每季度、重大架构变更后、添加 5+ 个新库后

---

## 📝 版本更新日志

### v2.1 (2025-10-31) - 精简优化
**删除**：
- 🗑️ 删除所有通用代码示例（约 400+ 行）
- 🗑️ common_patterns 模板改为简洁指导

**改进动机**: 通用代码示例对每个项目都不适用，应该由实际项目自己编写

---

### v2.0 (2025-10-30) - 智能化升级
**新增**：
- ✨ 智能自动评估流程
- ✨ 明确的评估标准阈值
- ✨ 质量评分系统（100 分制）
- ✨ 用户中断机制
- ✨ 标准输出格式
- ✨ 决策树可视化
- ✨ 执行检查清单
- ✨ 快速导航
- ✨ 常见问题解答

**改进**：
- 🔧 将"推荐"改为"强制"执行
- 🔧 添加具体的数值阈值
- 🔧 完善使用示例
- 🔧 增强操作流程说明

**修复**：
- 🐛 修复 AI 不自动执行的问题
- 🐛 明确何时询问用户、何时自动执行

### v1.0 (初始版本)
- 基础的 memory 维护指南
- 文件结构规范
- 构建、更新、审计流程

---

**最后更新**: 2025-10-31
