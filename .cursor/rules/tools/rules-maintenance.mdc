---
alwaysApply: false
---

# 规则编写与优化指南

## 🎯 核心目标

让 AI 能真正理解和执行规则，而不是把规则当成"装饰品"。

---

## 💡 三大核心原则

### 1. 可执行性优先 ⭐

**问题**：抽象原则 AI 无法执行
```markdown
❌ 遵循单一职责原则
❌ 保持代码简洁
❌ 注重可维护性
```

**解决**：转化为可检查的指令
```markdown
✅ Controller 不得直接调用 AFNetworking
✅ Request 类禁止导入 UIKit  
✅ 每个类不超过 300 行
```

**判断标准**：问自己"AI 能检查这条规则吗？"

---

### 2. 混合式设计 ⭐

**最佳实践**：抽象原则 + 可执行指令

```markdown
### 单一职责（SRP）
**原则**：一个类只有一个变化原因  
**执行**：
- Controller → 只协调视图，不处理网络/数据库
- Request → 只封装 API，不处理界面更新
- Cell → 只展示数据，通过 delegate 传递事件
```

**优势**：既有理论指导，又能具体落地

---

### 3. Always 规则必须精简 ⭐

**目标**：每个文件 < 60 行，总计 < 200 行

**精简技巧**：
- 用列表替代段落
- 合并相似内容
- 移除示例代码（放到按需规则）
- 使用缩写（SRP/OCP/DIP）

---

## ✅ 规则优化检查清单

### 可执行性检查
- [ ] 每个要求都有明确判断标准
- [ ] 禁止项清晰具体（不得、禁止）
- [ ] 推荐项有具体做法（使用、通过）
- [ ] 无模糊词汇（尽量、可能、考虑）

### 精简性检查（Always 规则）
- [ ] 总行数 < 60 行
- [ ] 无冗余段落
- [ ] 使用列表而非段落
- [ ] 无示例代码（或很短）

### 有效性检查
- [ ] 有前置检查点（强制分析）
- [ ] 使用混合式设计（原则 + 执行）
- [ ] 分层规则（强制 + 推荐）
- [ ] 实际可落地

---

## 🚫 模糊词汇黑名单

替换这些词汇，让规则可执行：

| ❌ 模糊词汇 | ✅ 明确表达 |
|------------|------------|
| 尽量 | 必须 / 禁止 |
| 可能 | 如果...则... |
| 考虑 | 检查 / 确认 |
| 适当 | 具体数值/标准 |
| 合理 | < N 行 / 不超过 |
| 优雅 | 使用 X 模式 |
| 简洁 | 删除重复代码 |
| 可读性好 | 添加注释 / 遵循命名规范 |

**使用方法**：
```bash
# 检查规则文件中的模糊词汇
grep -E "(尽量|可能|考虑|适当|合理|优雅)" .cursor/rules/*.mdc
```

---

## 🔧 强制前置分析技巧

**问题**：AI 直接写代码，忽略设计原则

**解决**：在规则开头添加检查点

```markdown
## 编码流程

> **在添加、修改、重构代码前，必须先分析：**
> 1. 这段代码的职责是什么？（SRP）
> 2. 是通过扩展还是修改实现？（OCP）
> 3. 需要依赖哪些抽象接口？（DIP）
```

**效果**：AI 会在编码前主动输出分析

---

## 🔄 规则审核流程（3步法）

### 第 1 步：静态检查
```bash
# 检查行数（Always 规则应 < 60 行）
wc -l .cursor/rules/*.mdc

# 搜索模糊词汇
grep -E "(尽量|可能|考虑|适当|合理)" .cursor/rules/*.mdc

# 检查是否有空洞的形容词
grep -E "(优雅|简洁|清晰|合理)" .cursor/rules/*.mdc
```

### 第 2 步：可执行性测试
对每条规则问 3 个问题：
1. **AI 能检查吗？** - 有明确判断标准
2. **AI 能识别违反吗？** - 有清晰边界
3. **能自动化吗？** - 可转化为 linter 规则

**示例**：
- ❌ "保持代码简洁" → 无法检查
- ✅ "每个方法不超过 50 行" → 可以检查

### 第 3 步：实战验证
让 AI 执行一个真实任务，观察：
- ✅ **AI 主动遵守** → 规则有效
- ⚠️ **需要提醒才遵守** → 规则不够明确，需强化
- ❌ **完全忽略** → 规则无效，需要重写

**验证任务示例**：
- 添加一个新功能（测试编码规范）
- 修复一个 Bug（测试问题处理流程）
- 重构现有代码（测试设计原则）

---

## 🎨 优化案例参考

### 案例 1：抽象 → 可执行

**优化前**：
```markdown
### 单一职责原则（SRP）
一个类应该只有一个引起它变化的原因
```

**优化后**：
```markdown
### 单一职责（SRP）
**原则**：一个类只有一个变化原因  
**执行**：
- Controller → 只协调视图，不处理网络/数据库
- Request → 只封装 API，不处理界面更新
```

---

### 案例 2：压缩长流程

**优化前**（39 行）：
```markdown
### Bug 处理流程
#### 诊断优先
- 先诊断，后修改：不要在未确认问题根源时就开始改代码
- 收集信息：完整的错误信息、复现步骤...
（详细描述 + 多个子章节）
```

**优化后**（5 行）：
```markdown
## Bug 处理流程
1. 先诊断：收集错误信息、复现步骤、网络响应、日志
2. 区分来源：errorCode != 0 → 后端问题；UI/状态错误 → 前端问题
3. 检查现有实现：是否已有类似功能？能否复用？
4. 描述问题 + 提供方案：向用户说明诊断结果和 2-3 个方案
5. 最小化修改：只改必要部分，一次一个问题，保持可回滚
```

---

### 案例 3：问题处理合集精简（problem-handling.mdc）

**文件定位**：
- 收集 AI 常见错误场景和解决方案
- 双重用途：提高 AI 精准度 + 用户快速查阅
- 持续添加新的问题处理案例

**优化前**（77 行）：
```markdown
## 🌐 技术术语沟通
### 问题：中文术语理解偏差
**现象**：...
**根本原因**：
1. 训练数据偏向英文 - 详细解释...
2. 技术概念关联强度 - 详细解释...

### 解决方案（按优先级）
**✅ 推荐：直接使用英文术语**
详细说明 + 示例...
（+ 执行规则、代码示例等）
```

**优化后**（33 行）：
```markdown
## 🌐 与 AI 沟通技术术语
### 核心建议（3 条）
### 常用术语对照（表格）
### 注意（1 条关键提醒）
```

**优化要点**：
- 删除过度详细的原因解释（保留现象描述）
- 简化解决方案层级（但保留完整性）
- 去除冗余的执行规则和代码示例
- 保持"问题 + 解决方案"结构清晰
- 适合持续添加新案例

---

## 🚨 常见反模式

### 反模式 1：空洞的形容词
❌ "编写优雅的代码"  
❌ "保持合理的复杂度"  
✅ "使用 Protocol 而非继承"  
✅ "圈复杂度 < 10"

### 反模式 2：无边界的要求
❌ "注意性能优化"  
❌ "避免过度设计"  
✅ "列表滚动帧率 > 55fps"  
✅ "一个方法不超过 50 行"

### 反模式 3：缺少触发条件
❌ "使用依赖注入"  
✅ "当类需要 3+ 个依赖时，使用依赖注入"

### 反模式 4：过度细节
❌ 第 1 步...第 2 步...第 15 步（超详细流程）  
✅ 5 步以内的关键流程 + 按需规则链接

### 反模式 5：重复说明
❌ 同时在标题、正文、示例中重复同一概念  
✅ 标题 → 概念，正文 → 执行，示例 → 对比

---

## 🚀 快速优化流程

1. **检查行数**：`wc -l your-rule.mdc`
   - Always 规则超过 60 行 → 需要精简

2. **转化抽象为具体**：
   - 找出所有抽象描述
   - 转化为可检查的指令

3. **添加前置检查**：
   - 在规则开头加入"编码流程"章节
   - 列出 3-5 个关键检查点

4. **验证效果**：
   - 让 AI 执行一次编码任务
   - 观察是否真的遵守了规则

---

## 📊 规则类型策略

### Always 规则（自动加载）
- ✅ 核心编码规范
- ✅ 设计原则（精简版）
- ✅ 强制约束（禁止/必须）
- ❌ 详细示例
- ❌ 冗长解释

### 按需规则（手动触发）
- ✅ 详细设计模式
- ✅ 完整决策树
- ✅ 大量示例
- ✅ 可选最佳实践

---

## ⚖️ 规则冲突处理

### 优先级原则
1. **安全性** > 可读性 > 性能
2. **强制约束**（禁止/必须）> 推荐做法
3. **项目级规则** > 个人偏好
4. **可量化规则** > 抽象原则

### 冲突解决示例

**示例 1：行数限制冲突**
```markdown
❌ 规则 A：每个类不超过 300 行
❌ 规则 B：不得拆分业务逻辑到多个类

解决：
✅ 优先规则 A（可量化）
✅ 改写规则 B：相关业务逻辑放在同一文件夹/模块
```

**示例 2：设计模式冲突**
```markdown
❌ 规则 A：使用继承实现代码复用
❌ 规则 B：优先组合而非继承

解决：
✅ 优先规则 B（设计原则）
✅ 删除规则 A，或改为"仅在特定场景使用继承"
```

### 冲突预防
- **定期审核**：每月检查规则是否有矛盾
- **标记例外**：特殊情况明确说明优先级
- **使用触发条件**：避免绝对化的规则

---

## 📌 规则版本管理

### 迭代原则
- **小步快跑**：每次只改 1-2 条规则
- **A/B 测试**：对比优化前后的 AI 表现
- **记录原因**：在 commit message 中说明改动理由
- **Diff 预览**：日常修改默认输出 diff（包括通过 Serena MCP 工具执行的修改），除非用户已确认可以跳过

### 版本标记建议
```markdown
---
alwaysApply: true
version: 2.1
lastUpdate: 2025-11-04
changelog:
  - v2.1: 精简 Bug 处理流程（39行 → 5行）
  - v2.0: 移除抽象描述，增加可执行性
  - v1.0: 初始版本
---
```

### 退化检测
如果 AI 表现变差：
1. **回滚**：恢复到上一版本
2. **对比**：逐条比较差异
3. **定位**：找出导致退化的具体规则
4. **修正**：调整或删除问题规则

### 演进跟踪
```bash
# 查看规则修改历史
git log --oneline -- .cursor/rules/

# 对比两个版本
git diff HEAD~5 HEAD -- .cursor/rules/00-personal.mdc
```

---

## 📊 规则有效性评估

### 量化指标
| 指标 | 目标值 | 测量方法 |
|------|--------|---------|
| AI 主动遵守率 | > 80% | 10 次任务中，8 次无需提醒 |
| 规则理解准确率 | 100% | AI 能正确解释规则含义 |
| 代码一次性通过率 | > 70% | 不需要修复违反规则的代码 |
| 规则查询响应 | < 5s | 按需规则能快速找到 |

### 定性评估
- ✅ AI 能否在编码前主动分析？
- ✅ AI 的回复是否变得更简洁？
- ✅ 生成的代码是否符合项目风格？
- ✅ 规则是否容易被团队成员理解？

### 评估周期
- **日常**：观察 AI 执行任务时的表现
- **周度**：统计违规次数和修正频率
- **月度**：全面审核规则有效性

---

## 💡 关键要点总结

### 核心原则
1. **可执行性优先**：AI 能检查 > 人能理解
2. **混合式设计**：原则 + 执行指令
3. **精简至上**：Always 规则 < 60 行/文件
4. **前置分析**：强制检查点，避免事后补救
5. **实测验证**：让 AI 执行真实任务

### 优化流程
1. 静态检查（行数 + 模糊词汇）
2. 可执行性测试（3 个问题）
3. 实战验证（观察 AI 表现）

### 持续改进
- 避免反模式（空洞形容词、无边界要求）
- 处理冲突（优先级原则）
- 版本管理（小步迭代、退化检测）
- 效果评估（量化 + 定性）

---

**版本**: 2.1  
**最后更新**: 2025-11-06  
**更新内容**:
- 新增案例 3：用户参考文件精简（problem-handling.mdc 优化实例）
- 明确用户参考文件 ≠ AI 规则的定位差异
