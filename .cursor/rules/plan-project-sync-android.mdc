---
alwaysApply: false
---
# Plan 文档同步规则（Android）

## 目标

实现 `项目.plan.md` 与项目代码的完全双向同步，确保架构一致性和代码质量。

---

## 1. 前置检查点 ⭐

### 代码修改后必须执行的检查

每次代码修改完成后，必须执行以下检查：

- [ ] 代码修改是否导致需求变更（功能变化、交互变化）
- [ ] 是否新增/修改了 base 类、工具类、架构组件
- [ ] 是否新增/修改了功能模块
- [ ] 是否修改了技术栈或目录结构
- [ ] UI 布局是否有变化（尺寸、颜色、间距等）

**执行时机**：每次代码修改完成后

**同步操作**（每次代码修改后必须执行）：
- 新增 base 类/工具类 → 更新 plan 的"技术栈概览"和"目录结构"
- 新增页面 → 在"第一部分：UI 布局"添加详细布局，在"第二部分：功能需求"添加功能说明
- 修改架构 → 更新相应章节
- 需求变更 → 更新功能需求部分
- **代码修改后，必须同步更新 plan 文档中相应的部分，确保文档与代码保持一致**

---

## 2. 架构检查规则 ⭐

### 生成代码前必须执行的检查

生成任何页面/功能代码前，必须：

1. **读取 plan 文档**
   - 检查"技术栈概览"中定义的架构
   - 检查"目录结构"规范

2. **搜索现有架构**
   - 搜索 base 类：`BaseActivity`、`BaseFragment`、`BaseViewModel`、`BaseView`、`BaseAdapter` 等
   - 搜索工具类：网络请求封装（Retrofit/OkHttp）、UI 工具、资源工具等
   - 搜索相关库的使用方式（Jetpack 组件、第三方库等）

3. **复用架构组件**
   - 存在 base 类时，必须继承 base 类
   - 存在 Toolbar/ActionBar base 类/工具时，必须使用
   - 存在工具类时，必须调用
   - 如果存在对应的库（第三方库或项目内库），必须使用，不得自行实现相同功能

**禁止事项**：
- 不得在未检查架构的情况下生成新页面
- 不得重复实现已有的 base 类和工具类
- 不得各页面独立实现相同功能（如 Toolbar、导航栏）

---

## 3. Plan 文档结构规范

### 强制的文档结构

```markdown
# 项目概述
（项目基本信息）

## 技术栈概览
（技术栈、库、框架、base 类、工具类）

## 目录结构
（代码目录结构）

---

# 第一部分：UI 布局

## 1. [页面名称]

**顶部区域**
- 元素、尺寸、颜色、间距

**内容区域**
- 容器尺寸、背景色、圆角
- 元素布局、约束

**底部按钮**
- 尺寸、颜色、文字、圆角

（参考 plan-reference.mdc 中的样式）

---

# 第二部分：功能需求

## 1. [功能模块]

### 1.1 [具体功能]
- 交互逻辑
- 按钮点击行为
- 数据展示规则
- 筛选/搜索逻辑
- 页面跳转流程
```

### 禁止事项

- 不得将 UI 布局和功能需求混写在同一章节
- 不得省略"技术栈概览"和"目录结构"部分
- 不得在功能需求中描述 UI 细节（尺寸、颜色等）

### 样式参考

编写或更新 plan 文档时，必须参考：
- `plan-reference.mdc` - UI 布局描述样式、术语对照表

---

## 4. 代码清理规则 ⭐

### 问题 1：模拟数据切换到真实接口

从模拟数据切换到真实接口时，必须删除：

- [ ] 所有模拟数据定义（List、Map 等）
- [ ] Mock 函数和模拟方法
- [ ] 临时的模拟 Model/Entity（如果真实 Model 已替换）
- [ ] 测试用的假数据填充代码
- [ ] 遗留的模拟数据注释代码

### 问题 2：UI 修改导致的冗余代码

第二次 UI 调整时，必须删除：

- [ ] 第一版不再使用的 UI 组件（View、Layout 等）
- [ ] 第一版的布局约束代码（ConstraintLayout、LinearLayout 等）
- [ ] 不再使用的颜色/尺寸资源（colors.xml、dimens.xml）
- [ ] 废弃的 UI 相关函数和方法

### 问题 3：代码修复时的版本清理

修复失败后，下一次修复前必须：

- [ ] 完全删除上一次失败的修复代码
- [ ] 恢复到修复前的稳定状态
- [ ] 清理注释掉的失败尝试代码

**清理步骤**：
1. 识别冗余代码（模拟数据、废弃 UI、失败修复）
2. 确认要删除的代码范围
3. 执行删除操作
4. 验证删除后代码的完整性

---

## 5. 代码复杂度控制

### 拆分原则（基于业务复杂度）

**必须拆分的情况**：

- 一个页面有 3 种以上不同展示形式
- 单个文件包含多个独立的业务逻辑模块
- 代码重复度高，可以提取为公共组件
- 文件职责不单一，承担了多个功能

### 多形式页面拆分规则

当一个页面有多种展示形式时：

- 将不同形式拆分为独立的 View/Layout 文件
- 使用基础 View + 子 View 组合方式
- 通过配置/枚举切换不同 View
- 示例：`DetailActivity` 有 6 种形式 → 拆分为 `DetailBaseView` + `DetailTypeAView` + `DetailTypeBView` 等

### 推荐实践

- 优先保证代码清晰度和可维护性
- 根据实际业务需求决定是否拆分
- 不盲目追求文件小而拆分合理的业务逻辑

### 禁止事项

- 不得将所有展示形式的逻辑堆积在一个文件中
- 不得保留废弃的代码版本（即使注释掉也要删除）

---

## 执行时机总结

| 时机 | 必须执行的操作 |
|------|---------------|
| 代码修改后 | 检查是否需要更新 plan 文档 |
| 生成代码前 | 检查 plan 架构，搜索现有 base 类和工具类 |
| UI 修改后 | 删除废弃的 UI 代码 |
| 接口切换后 | 删除模拟数据代码 |
| 修复失败后 | 删除失败的修复代码 |
